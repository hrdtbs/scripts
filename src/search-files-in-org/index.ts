import { parseArgs } from "https://deno.land/std@0.220.1/cli/parse_args.ts";
import { Octokit } from "npm:@octokit/rest@20.0.2";
import { load } from "https://deno.land/std@0.220.1/dotenv/mod.ts";
import { join } from "https://deno.land/std@0.220.1/path/mod.ts";
import { ensureDir } from "https://deno.land/std@0.220.1/fs/ensure_dir.ts";

interface SearchResult {
  repository: string;
  file: string;
  path: string;
  url: string;
  matches: SearchMatch[];
}

interface SearchMatch {
  lineNumber: number;
  line: string;
  context: string[];
}

interface SearchSummary {
  organization: string;
  query: string;
  extensions: string[];
  timestamp: string;
  summary: {
    totalRepositories: number;
    repositoriesWithMatches: number;
    totalMatches: number;
    totalFiles: number;
  };
  results: SearchResult[];
  errors: Array<{
    repository: string;
    error: string;
  }>;
}

interface SearchFilesInOrgOptions {
  org: string;
  query: string;
  extensions?: string[];
  output?: string;
  format?: "json" | "csv";
}

interface SearchFilesInOrgResult {
  success: boolean;
  summary?: {
    organization: string;
    query: string;
    extensions: string[];
    timestamp: string;
    totalRepositories: number;
    repositoriesWithMatches: number;
    totalMatches: number;
    totalFiles: number;
    errorCount: number;
    searchStats: Array<{
      extension: string;
      totalFound: number;
      retrieved: number;
      hitLimit: boolean;
    }>;
  };
  outputPath?: string;
  error?: string;
}

// Octokit„ÅÆÂàùÊúüÂåñ
function createOctokit(token: string): Octokit {
  return new Octokit({
    auth: token,
  });
}

async function searchInOrganization(
  octokit: Octokit,
  org: string,
  query: string,
  extensions: string[]
): Promise<{
  results: SearchResult[];
  errors: Array<{ repository: string; error: string }>;
  searchStats: {
    extension: string;
    totalFound: number;
    retrieved: number;
    hitLimit: boolean;
  }[];
}> {
  const allResults: SearchResult[] = [];
  const errors: Array<{ repository: string; error: string }> = [];
  const searchStats: {
    extension: string;
    totalFound: number;
    retrieved: number;
    hitLimit: boolean;
  }[] = [];

  try {
    // Êã°ÂºµÂ≠êÊØé„Å´Ê§úÁ¥¢„ÇíÂÆüË°åÔºàGitHub Search API„ÅÆÂà∂Èôê„Å´„Çà„ÇäÔºâ
    for (const extension of extensions) {
      console.log(`üîç Searching: .${extension.replace(".", "")} files`);

      let page = 1;
      let hasNextPage = true;
      let totalFound = 0;
      let retrieved = 0;
      let hitLimit = false;

      while (hasNextPage) {
        try {
          const extensionWithoutDot = extension.replace(".", "");
          const searchQuery = `${query} org:${org} extension:${extensionWithoutDot}`;

          const { data } = await octokit.rest.search.code({
            q: searchQuery,
            per_page: 100,
            page,
            headers: {
              Accept: "application/vnd.github.v3.text-match+json",
            },
          });

          console.log(`  Page ${page}: ${data.items.length} results`);

          // ÂàùÂõû„Éö„Éº„Ç∏„ÅßÁ∑èÊï∞„ÇíË®òÈå≤
          if (page === 1) {
            totalFound = data.total_count;
          }

          for (const item of data.items) {
            try {
              const repoName = item.repository.name;

              // „Ç¢„Éº„Ç´„Ç§„Éñ„Åï„Çå„Åü„É™„Éù„Ç∏„Éà„É™„Çí„Çπ„Ç≠„ÉÉ„Éó
              if (item.repository.archived) {
                continue;
              }

              // GitHub Search API„ÅÆÁµêÊûú„Å´„ÅØ„ÉÜ„Ç≠„Çπ„Éà„Éû„ÉÉ„ÉÅ„ÅÆÊÉÖÂ†±„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ
              // „Åù„Çå„ÇíÊ¥ªÁî®„Åó„Å¶„Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÅÆÂèñÂæó„ÇíÊúÄÂ∞èÂåñ
              const matches: SearchMatch[] = [];

              if (item.text_matches && item.text_matches.length > 0) {
                // „ÉÜ„Ç≠„Çπ„Éà„Éû„ÉÉ„ÉÅÊÉÖÂ†±„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åù„Çå„Çí‰ΩøÁî®
                for (const textMatch of item.text_matches) {
                  if (textMatch.fragment) {
                    const lines = textMatch.fragment.split("\n");
                    lines.forEach((line, index) => {
                      if (line.toLowerCase().includes(query.toLowerCase())) {
                        matches.push({
                          lineNumber: index + 1, // ÂÆüÈöõ„ÅÆË°åÁï™Âè∑„ÅØÂèñÂæóÂõ∞Èõ£„Å™„Åü„ÇÅÁõ∏ÂØæ‰ΩçÁΩÆ
                          line: line.trim(),
                          context: lines.slice(
                            Math.max(0, index - 2),
                            Math.min(lines.length, index + 3)
                          ),
                        });
                      }
                    });
                  }
                }
              } else {
                // „ÉÜ„Ç≠„Çπ„Éà„Éû„ÉÉ„ÉÅÊÉÖÂ†±„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÁ∞°Âçò„Å™„Éû„ÉÉ„ÉÅÊÉÖÂ†±„ÅÆ„Åø‰ΩúÊàê
                matches.push({
                  lineNumber: 1,
                  line: `Match found: "${query}"`,
                  context: [`File: ${item.name}`],
                });
              }

              if (matches.length > 0) {
                allResults.push({
                  repository: repoName,
                  file: item.name,
                  path: item.path,
                  url: item.html_url,
                  matches,
                });
                retrieved++;
              }
            } catch (itemError) {
              const repoName = item.repository?.name || "unknown";
              console.warn(
                `Item processing error ${repoName}/${item.path}:`,
                itemError
              );
              errors.push({
                repository: repoName,
                error:
                  itemError instanceof Error
                    ? itemError.message
                    : String(itemError),
              });
            }
          }

          // „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥Âà∂Âæ°
          hasNextPage = data.items.length === 100; // ÁµêÊûú„Åå100‰ª∂„ÅÆÂ†¥Âêà„ÅØÊ¨°„ÅÆ„Éö„Éº„Ç∏„Åå„ÅÇ„ÇãÂèØËÉΩÊÄß
          page++;

          // GitHub Search API„ÅØÊúÄÂ§ß1000‰ª∂Ôºà10„Éö„Éº„Ç∏Ôºâ„Åæ„Åß„ÅÆÂà∂Èôê„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅ
          // „Åù„Çå„ÇíË∂Ö„Åà„ÇãÂ†¥Âêà„ÅØË≠¶Âëä„ÇíË°®Á§∫
          if (page > 10) {
            console.warn(`‚ö†Ô∏è  Search results exceed 1000 items (${extension})`);
            console.warn(
              `    Due to GitHub Search API limitations, some results may not be retrieved`
            );
            hitLimit = true;
            hasNextPage = false;
          }

          // Rate limitÂØæÁ≠ñ„ÅßÂ∞ë„ÅóÂæÖÊ©ü
          if (hasNextPage) {
            await new Promise((resolve) => setTimeout(resolve, 200));
          }
        } catch (searchError) {
          console.warn(
            `Search error (${extension}, page ${page}):`,
            searchError
          );
          errors.push({
            repository: `search-${extension}-page${page}`,
            error:
              searchError instanceof Error
                ? searchError.message
                : String(searchError),
          });
          break;
        }
      }

      // Ê§úÁ¥¢Áµ±Ë®à„ÇíË®òÈå≤
      searchStats.push({
        extension: extension.replace(".", ""),
        totalFound,
        retrieved,
        hitLimit,
      });

      console.log(
        `  üìä ${extension}: ${retrieved}/${totalFound} items retrieved ${
          hitLimit ? "(limited)" : ""
        }`
      );

      // Êã°ÂºµÂ≠êÈñì„Åß„ÇÇÂ∞ë„ÅóÂæÖÊ©ü
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
  } catch (error) {
    console.error("Organization search error:", error);
    errors.push({
      repository: "organization-search",
      error: error instanceof Error ? error.message : String(error),
    });
  }

  return { results: allResults, errors, searchStats };
}

function convertToCSV(summary: SearchSummary): string {
  const headers = [
    "repository",
    "file",
    "path",
    "url",
    "lineNumber",
    "matchedLine",
    "contextBefore",
    "contextAfter",
  ];

  const rows: string[] = [];

  for (const result of summary.results) {
    for (const match of result.matches) {
      const contextLines = match.context;
      const matchIndex = contextLines.findIndex((line) =>
        line.toLowerCase().includes(summary.query.toLowerCase())
      );

      const contextBefore =
        matchIndex > 0 ? contextLines.slice(0, matchIndex).join(" | ") : "";
      const contextAfter =
        matchIndex < contextLines.length - 1
          ? contextLines.slice(matchIndex + 1).join(" | ")
          : "";

      rows.push(
        [
          result.repository,
          result.file,
          result.path,
          result.url,
          match.lineNumber.toString(),
          `"${match.line.replace(/"/g, '""')}"`,
          `"${contextBefore.replace(/"/g, '""')}"`,
          `"${contextAfter.replace(/"/g, '""')}"`,
        ].join(",")
      );
    }
  }

  return [headers.join(","), ...rows].join("\n");
}

// „É°„Ç§„É≥„ÅÆ„Éï„Ç°„Ç§„É´Ê§úÁ¥¢„É≠„Ç∏„ÉÉ„ÇØ
async function searchFilesInOrg(
  options: SearchFilesInOrgOptions
): Promise<SearchFilesInOrgResult> {
  try {
    const {
      org,
      query,
      extensions = ["ts", "js", "tsx", "jsx"],
      output = ".output",
      format = "json",
    } = options;

    // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if (!org) {
      return { success: false, error: "Organization name is required" };
    }

    if (!query) {
      return { success: false, error: "Search query is required" };
    }

    if (!["json", "csv"].includes(format)) {
      return { success: false, error: "Format must be json or csv" };
    }

    // .env„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø
    const env = await load();
    const token = env.GH_TOKEN;

    if (!token) {
      return {
        success: false,
        error: "GH_TOKEN environment variable is not set",
      };
    }

    const octokit = createOctokit(token);

    // Êã°ÂºµÂ≠ê„ÅÆÊ≠£Ë¶èÂåñ
    const normalizedExtensions = extensions.map((ext) =>
      ext.trim().startsWith(".") ? ext.trim() : `.${ext.trim()}`
    );

    console.log(`üîç Starting search...`);
    console.log(`- Organization: ${org}`);
    console.log(`- Search query: "${query}"`);
    console.log(`- Target extensions: ${normalizedExtensions.join(", ")}`);

    // ÁµÑÁπîÂÖ®‰Ωì„Åß‰∏ÄÊã¨Ê§úÁ¥¢„ÇíÂÆüË°å
    console.log("üîç Executing search across organization...");
    const {
      results: allResults,
      errors,
      searchStats,
    } = await searchInOrganization(octokit, org, query, normalizedExtensions);

    // ÁµêÊûú„Çí„É™„Éù„Ç∏„Éà„É™ÊØé„Å´„Åæ„Å®„ÇÅ„Çã
    const repositoryGroups = new Map<string, SearchResult[]>();
    allResults.forEach((result) => {
      if (!repositoryGroups.has(result.repository)) {
        repositoryGroups.set(result.repository, []);
      }
      repositoryGroups.get(result.repository)!.push(result);
    });

    console.log(`\n‚úÖ Search completed`);
    console.log(`- Total matches: ${allResults.length}`);
    console.log(`- Repositories with matches: ${repositoryGroups.size}`);

    // „É™„Éù„Ç∏„Éà„É™ÊØé„ÅÆË©≥Á¥∞Ë°®Á§∫
    if (repositoryGroups.size > 0) {
      console.log(`\nüìã Repository match details:`);

      // „É™„Éù„Ç∏„Éà„É™„Çí„Éû„ÉÉ„ÉÅÊï∞„Åß„ÇΩ„Éº„ÉàÔºàÈôçÈ†ÜÔºâ
      const sortedRepositories = Array.from(repositoryGroups.entries())
        .map(([repo, results]) => ({
          repository: repo,
          fileCount: results.length,
          matchCount: results.reduce((sum, r) => sum + r.matches.length, 0),
          results,
        }))
        .sort((a, b) => b.matchCount - a.matchCount);

      sortedRepositories.forEach(
        ({ repository, fileCount, matchCount, results }) => {
          console.log(
            `  üìÅ ${repository}: ${matchCount} matches (${fileCount} files)`
          );

          // „Éï„Ç°„Ç§„É´Êï∞„ÅåÂ§ö„ÅÑÂ†¥Âêà„ÅØ‰∏ä‰Ωç5„Å§„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„ÅøË°®Á§∫
          if (fileCount > 5) {
            const topFiles = results
              .sort((a, b) => b.matches.length - a.matches.length)
              .slice(0, 5);

            topFiles.forEach((result) => {
              console.log(
                `    üìÑ ${result.path}: ${result.matches.length} matches`
              );
            });

            if (fileCount > 5) {
              console.log(`    ... and ${fileCount - 5} more files`);
            }
          } else {
            // „Éï„Ç°„Ç§„É´Êï∞„ÅåÂ∞ë„Å™„ÅÑÂ†¥Âêà„ÅØÂÖ®„Å¶Ë°®Á§∫
            results
              .sort((a, b) => b.matches.length - a.matches.length)
              .forEach((result) => {
                console.log(
                  `    üìÑ ${result.path}: ${result.matches.length} matches`
                );
              });
          }
        }
      );
    }

    // ÁµêÊûú„Çí„Åæ„Å®„ÇÅ„Çã
    const repositoriesWithMatches = repositoryGroups.size;
    const totalMatches = allResults.reduce(
      (sum, r) => sum + r.matches.length,
      0
    );

    const summary: SearchSummary = {
      organization: org,
      query: query,
      extensions: normalizedExtensions,
      timestamp: new Date().toISOString(),
      summary: {
        totalRepositories: repositoryGroups.size || 0,
        repositoriesWithMatches,
        totalMatches,
        totalFiles: allResults.length,
      },
      results: allResults,
      errors,
    };

    // Âá∫Âäõ
    await ensureDir(output);
    const outputPath = join(output, `${org}-search-results.${format}`);

    if (format === "csv") {
      const csvContent = convertToCSV(summary);
      await Deno.writeTextFile(outputPath, csvContent);
    } else {
      await Deno.writeTextFile(outputPath, JSON.stringify(summary, null, 2));
    }

    const resultSummary = {
      organization: org,
      query: query,
      extensions: normalizedExtensions,
      timestamp: new Date().toISOString(),
      totalRepositories: repositoryGroups.size,
      repositoriesWithMatches,
      totalMatches,
      totalFiles: allResults.length,
      errorCount: errors.length,
      searchStats,
    };

    return { success: true, summary: resultSummary, outputPath };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return { success: false, error: errorMessage };
  }
}

// CLIÁî®„ÅÆ„É°„Ç§„É≥Âá¶ÁêÜ
async function main() {
  const args = parseArgs(Deno.args, {
    string: ["org", "query", "extensions", "output", "format"],
    default: {
      output: ".output",
      format: "json",
      extensions: "ts,js,tsx,jsx",
    },
  });

  if (!args.org) {
    console.error("Error: --org option is required");
    Deno.exit(1);
  }

  if (!args.query) {
    console.error("Error: --query option is required");
    Deno.exit(1);
  }

  if (!["json", "csv"].includes(args.format)) {
    console.error("Error: --format option must be json or csv");
    Deno.exit(1);
  }

  const extensions = args.extensions
    .split(",")
    .map((ext) => (ext.trim().startsWith(".") ? ext.trim() : `.${ext.trim()}`));

  const result = await searchFilesInOrg({
    org: args.org,
    query: args.query,
    extensions,
    output: args.output,
    format: args.format as "json" | "csv",
  });

  if (!result.success) {
    console.error(`Error: ${result.error}`);
    Deno.exit(1);
  }

  if (result.summary && result.outputPath) {
    // „Çµ„Éû„É™„Éº„ÇíË°®Á§∫
    console.log(`\nüìä Search result summary:`);
    console.log(`- Organization: ${result.summary.organization}`);
    console.log(`- Search query: "${result.summary.query}"`);
    console.log(`- Target extensions: ${result.summary.extensions.join(", ")}`);
    console.log(`- Repositories searched: ${result.summary.totalRepositories}`);
    console.log(
      `- Repositories with matches: ${result.summary.repositoriesWithMatches}`
    );
    console.log(`- Files with matches: ${result.summary.totalFiles}`);
    console.log(`- Total matches: ${result.summary.totalMatches}`);
    console.log(`- Errors: ${result.summary.errorCount}`);
    console.log(`- Output format: ${args.format}`);
    console.log(`- Output file: ${result.outputPath}`);

    // Ê§úÁ¥¢Áµ±Ë®à„ÅÆË©≥Á¥∞Ë°®Á§∫
    if (result.summary.searchStats.length > 0) {
      console.log(`\nüìà Search statistics:`);
      result.summary.searchStats.forEach((stat) => {
        const status = stat.hitLimit ? "‚ö†Ô∏è Limited" : "‚úÖ Complete";
        console.log(
          `  .${stat.extension}: ${stat.retrieved}/${stat.totalFound} items ${status}`
        );
      });

      const hasLimits = result.summary.searchStats.some(
        (stat) => stat.hitLimit
      );
      if (hasLimits) {
        console.log(
          `\n‚ö†Ô∏è  Note: Some extensions hit the GitHub Search API 1000 item limit`
        );
        console.log(
          `   To get more results, make your search query more specific`
        );
      }
    }
  }
}

// TUIÁî®„ÅÆÂÆüË°åÈñ¢Êï∞
export async function executeSearchFilesInOrg(): Promise<void> {
  const { Input, Select } = await import(
    "https://deno.land/x/cliffy@v1.0.0-rc.3/prompt/mod.ts"
  );

  try {
    // ÁµÑÁπîÂêç„ÅÆÂÖ•Âäõ
    const org = await Input.prompt({
      message: "Enter organization name:",
      validate: (value: string) =>
        value.trim().length > 0 ? true : "Organization name is required",
    });

    // Ê§úÁ¥¢„ÇØ„Ç®„É™„ÅÆÂÖ•Âäõ
    const query = await Input.prompt({
      message: "Enter search query:",
      validate: (value: string) =>
        value.trim().length > 0 ? true : "Search query is required",
    });

    // Êã°ÂºµÂ≠ê„ÅÆÂÖ•Âäõ
    const extensionsInput = await Input.prompt({
      message: "Enter file extensions (comma-separated, e.g., ts,js,tsx,jsx):",
      default: "ts,js,tsx,jsx",
      validate: (value: string) =>
        value.trim().length > 0 ? true : "File extensions are required",
    });

    // Âá∫ÂäõÂΩ¢Âºè„ÅÆÈÅ∏Êäû
    const format = await Select.prompt({
      message: "Select output format:",
      options: [
        { name: "JSON", value: "json" },
        { name: "CSV", value: "csv" },
      ],
      default: "json",
    });

    // Êã°ÂºµÂ≠ê„ÅÆÊ≠£Ë¶èÂåñ
    const extensions = extensionsInput
      .split(",")
      .map((ext) =>
        ext.trim().startsWith(".") ? ext.trim() : `.${ext.trim()}`
      );

    // Ë®≠ÂÆöÂÜÖÂÆπ„ÅÆÁ¢∫Ë™ç
    console.log("\nüìã Settings:");
    console.log(`Organization: ${org}`);
    console.log(`Search Query: "${query}"`);
    console.log(`File Extensions: ${extensions.join(", ")}`);
    console.log(`Output Format: ${format}`);

    const options: SearchFilesInOrgOptions = {
      org,
      query,
      extensions,
      format: format as "json" | "csv",
    };

    const result = await searchFilesInOrg(options);

    if (result.success && result.summary && result.outputPath) {
      console.log(
        `\nüìù Search results have been output to ${result.outputPath}`
      );

      console.log(`\nüìä Summary:`);
      console.log(`- Organization: ${result.summary.organization}`);
      console.log(`- Search query: "${result.summary.query}"`);
      console.log(
        `- Target extensions: ${result.summary.extensions.join(", ")}`
      );
      console.log(
        `- Repositories searched: ${result.summary.totalRepositories}`
      );
      console.log(
        `- Repositories with matches: ${result.summary.repositoriesWithMatches}`
      );
      console.log(`- Files with matches: ${result.summary.totalFiles}`);
      console.log(`- Total matches: ${result.summary.totalMatches}`);
      console.log(`- Errors: ${result.summary.errorCount}`);
      console.log(`- Output format: ${format}`);
      console.log(`- Output file: ${result.outputPath}`);

      // Ê§úÁ¥¢Áµ±Ë®à„ÅÆË©≥Á¥∞Ë°®Á§∫
      if (result.summary.searchStats.length > 0) {
        console.log(`\nüìà Search statistics:`);
        result.summary.searchStats.forEach((stat) => {
          const status = stat.hitLimit ? "‚ö†Ô∏è Limited" : "‚úÖ Complete";
          console.log(
            `  .${stat.extension}: ${stat.retrieved}/${stat.totalFound} items ${status}`
          );
        });

        const hasLimits = result.summary.searchStats.some(
          (stat) => stat.hitLimit
        );
        if (hasLimits) {
          console.log(
            `\n‚ö†Ô∏è  Note: Some extensions hit the GitHub Search API 1000 item limit`
          );
          console.log(
            `   To get more results, make your search query more specific`
          );
        }
      }
    } else {
      console.log(`Error: ${result.error}`);
    }
  } catch (error) {
    console.error("An error occurred:", error);
  }
}

// Export functions for TUI
export {
  searchFilesInOrg,
  type SearchFilesInOrgOptions,
  type SearchFilesInOrgResult,
};

if (import.meta.main) {
  main();
}
